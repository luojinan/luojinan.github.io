<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luojinan.github.io/</id>
    <title>Gridea</title>
    <updated>2019-08-15T02:04:29.701Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luojinan.github.io/"/>
    <link rel="self" href="https://luojinan.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://luojinan.github.io//images/avatar.png</logo>
    <icon>https://luojinan.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[防抖工具函数封装]]></title>
        <id>https://luojinan.github.io//post/fang-dou-gong-ju-han-shu-feng-zhuang</id>
        <link href="https://luojinan.github.io//post/fang-dou-gong-ju-han-shu-feng-zhuang">
        </link>
        <updated>2019-08-15T02:03:59.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>防抖函数<code>debounce</code>用于<strong>解决连续触发同一事件问题</strong>，限制延迟一定时间后触发事件</p>
</blockquote>
<h3 id="效果图">效果图</h3>
<ul>
<li><strong>没有防抖的输入框</strong>
<img src="https://luojinan.github.io//post-images/1565834657948.gif" alt=""></li>
<li><strong>加了防抖的输入框</strong>
<img src="https://luojinan.github.io//post-images/1565834660305.gif" alt=""></li>
</ul>
<hr>
<h3 id="使用方法">使用方法</h3>
<p>1、<strong>在import部分 引入并声明构造函数</strong></p>
<pre><code class="language-js">  import Debounce from '@/common/libs/debounce'
  let debounce = Debounce()
</code></pre>
<p>2、<strong>在要节流的方法处使用</strong>(传入回调函数外，还可传入回调函数需要的参数，见源码)</p>
<pre><code class="language-js"> changePhone (e) {
   debounce(() =&gt; {
     console.log(e.mp.detail, '输入的手机号')
     this.phone = e.mp.detail
   })
 }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[短信倒计时]]></title>
        <id>https://luojinan.github.io//post/duan-xin-dao-ji-shi</id>
        <link href="https://luojinan.github.io//post/duan-xin-dao-ji-shi">
        </link>
        <updated>2019-08-14T12:27:06.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>调用发送短信接口后，<strong>开启倒计时</strong>、并<strong>使按钮不可点击</strong></p>
</blockquote>
<h3 id="效果图">效果图</h3>
<p><img src="https://luojinan.github.io//post-images/1565785631215.gif" alt=""></p>
<hr>
<h3 id="实现步骤">实现步骤</h3>
<ul>
<li><strong>点击按钮</strong>，调用短信接口成功后把 <code>canClick = false</code></li>
<li>vue项目使用<code>watch</code>监听<code>canClick</code>标志符
<ul>
<li><code>canClick</code>变化为<code>true</code>或<code>false</code>都会<strong>触发监听</strong></li>
<li>而<strong>倒计时</strong>只会在<code>canClick</code>由<code>true</code>变为<code>false</code>（点击发送）时触发</li>
</ul>
</li>
<li><strong>倒计时结束</strong>清除定时器，并把 <code>canClick = true</code></li>
</ul>
<hr>
<h3 id="部分示例代码">部分示例代码</h3>
<pre><code class="language-js">watch: {
    canClick (e) {
        // 监听canclick变为false时执行倒计时
        if ( !e ) {
            clearInterval( this.timer )   // 确保上一次的定时器被清除(可能有延迟)
            this.timer = setInterval( ( )  =&gt; {
                this.second--
                // 当秒数减为0时，重置秒数和按钮可点击状态
                if (!this.second) {
                    this.second = 60
                    this.canClick = true
                    clearInterval(this.timer)
                    this.disabled = false
                }
            }, 1000)    //每隔1000毫秒减1 second
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[节流工具函数封装]]></title>
        <id>https://luojinan.github.io//post/jie-liu-gong-ju-han-shu-feng-zhuang</id>
        <link href="https://luojinan.github.io//post/jie-liu-gong-ju-han-shu-feng-zhuang">
        </link>
        <updated>2019-08-14T11:40:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>节流函数<code>throttle</code>用于<strong>解决频繁操作问题</strong>，限制一定时间内点击不触发事件</p>
</blockquote>
<hr>
<p>[toc]</p>
<hr>
<h3 id="一-不同的实现方法">一、不同的实现方法</h3>
<h4 id="1-定时器">1、定时器</h4>
<ul>
<li><strong>缺点</strong></li>
</ul>
<blockquote>
<p><strong>首次也会被延迟</strong>，不会立即执行</p>
</blockquote>
<pre><code class="language-js">// 使用setTimeout实现
function throttle (fn, delay) {
  let flag = false
  if (!flag) {
    return function() {
      let context = this, args = arguments
      flag = setTimeout(() =&gt; {
        fn.apply(context, args)
        flag = true
      }, delay)
    }
  }
}
</code></pre>
<h4 id="2-时间戳">2、时间戳</h4>
<ul>
<li><strong>缺点</strong></li>
</ul>
<blockquote>
<p>在不可操作时间段中，点击无效，<strong>时间段结束不自动执行</strong>，要再点击一次
有时需求，频繁操作后，<strong>要记住最后一次点击，并定时结束自动执行</strong></p>
</blockquote>
<pre><code class="language-js">//  比较两次时间戳的间隔 是否大于等于 指定的时间 来决定是否执行事件回调
function throttle (fn, delay) {
  let start = 0
  return function () {
    if (now - start &gt;= delay) {
        let context = this, args = arguments, now = new Date()
        fn.apply(context, args);
        start = now
    }
  }
}
</code></pre>
<h3 id="二-最优方法">二、最优方法</h3>
<ul>
<li><strong>结合使用</strong></li>
</ul>
<blockquote>
<p>首次执行使用<strong>时间戳方法</strong>（非频繁操作）
1、后续继续使用<strong>时间戳方法</strong>(频繁操作且不需要自动执行最后一次)
2、后续执行包括记住最后一次点击都使用<strong>定时器方法</strong>（频繁操作且自动执行最后一次）</p>
</blockquote>
<hr>
<h3 id="三-开始封装工具函数">三、开始封装工具函数</h3>
<blockquote>
<p>这里以<code>vue</code>项目为例子封装</p>
</blockquote>
<h4 id="1-utils文件夹封装">1、utils文件夹封装</h4>
<blockquote>
<p>注意：这里利用了<code>闭包的方式（且不自执行）</code>
<code>function return function</code>来设置<code>局部变量</code>
关于<code>局部变量</code>看<strong>第四点</strong></p>
</blockquote>
<pre><code class="language-js">function Throttle (func, wait, trailing) {
    console.log('执行函数') // 这是闭包，函数只要引入页面就执行了
    let timer = null
    let start = 0
    return function () {
        let now = new Date()
        let remaining = wait - (now - start)
        console.log(remaining)
        // 拦截：延迟时间&gt;多次点击间隔时间，执行：多次点击间隔时间&gt;延迟时间
        if ((now - start) &gt;= wait) {
            // 由于setTimeout存在最小时间精度问题，因此会存在到达wait的时间间隔
            // 但之前设置的setTimeout操作还没被执行，因此为保险起见，这里先清理setTimeout操作
            timer &amp;&amp; clearTimeout(timer)
            timer = null
            start = now
            console.log('非频繁操作，点击间隔为：',remaining)
            return func()
        } else if (!timer &amp;&amp; trailing) {
            // trailing有值时，延时执行func函数
            // 频繁操作，第一次设置定时器之后，之后的不会再走到这里创建定时器
            // 清除问题，只能在第二有效点击的时候才会清除
            timer = setTimeout(() =&gt; {
                timer = null
                console.log('频繁操作，定时器延时执行')
                return func
            }, wait)
        }
    }
}
</code></pre>
<h4 id="2-页面内调用">2、页面内调用</h4>
<blockquote>
<p>1、引入工具函数<code>utils文件夹</code>
2、并执行<code>节流闭包函数</code>，外部（即：初始化局部变量），不会执行内部<code>return</code>的<code>function</code></p>
</blockquote>
<pre><code class="language-js">import {Throttle} from '@/common/libs/throttle'
let throttle = Throttle()
</code></pre>
<blockquote>
<p>3、在<code>methods</code>相应<strong>需要节流的方法</strong>里调用</p>
</blockquote>
<pre><code class="language-js">methods:{
    handleIcon (index) {
        // 执行节流闭包函数，内部 function ,已初始化时间，并以此计算点击间隔
        // 传入 回调函数fn，不可操作时长
        throttle(this.handleClick(index),3000)
    },
    handleClick(index){
        console.log( `点击了第${index}个按钮` )
    }
}
</code></pre>
<hr>
<h3 id="四-局部变量问题">四、局部变量问题</h3>
<blockquote>
<p>以此<strong>抽离封装函数</strong>，做到不需要在<code>vue</code>的<code>data</code>里设置<code>变量</code>
否则要在<code>data</code>里存入<code>点击时间戳</code>来做<strong>点击间隔判断</strong></p>
</blockquote>
<blockquote>
<p>局部变量概念，把变量设为私有变量，外部函数无法修改，<strong>只能被自己修改，或者内部函数修改</strong></p>
</blockquote>
<p><code>function return function</code> 方式，要分开执行<code>外部</code>和<code>内部方法</code></p>
<ul>
<li>一次用于<strong>初始化局部变量</strong></li>
<li>一次用于<strong>执行内部操作</strong>
<img src="https://luojinan.github.io//post-images/1565782932409.png" alt=""></li>
</ul>
<hr>
<h3 id="五-回调函数无法传参问题">五、回调函数无法传参问题</h3>
<blockquote>
<p>到这一步，在项目页面已经可以实现节流（既能第一次生效又能自动执行最后一次）
但是，发现传入回调函数是整个函数，不带<code>( )</code>，即：<strong>无法带参数</strong></p>
</blockquote>
<h4 id="1-尝试不传入整个函数而是传入func">1、尝试不传入整个函数,而是传入<code>func()</code></h4>
<ul>
<li><strong>当前情况</strong></li>
<li><strong>传入的只能是整个函数，而不发传入参数</strong>
<img src="https://luojinan.github.io//post-images/1565782935988.png" alt=""></li>
</ul>
<hr>
<ul>
<li><strong>修改为可以传入<code>function()</code></strong></li>
<li><strong>导致传入的不再是函数，而是一个值</strong>
<img src="https://luojinan.github.io//post-images/1565782951392.png" alt=""></li>
</ul>
<hr>
<h4 id="2-曲线救国给工具函数传参数而不是给回调函数传参数">2、曲线救国,给工具函数传参数,而不是给回调函数传参数</h4>
<ul>
<li><strong>节流工具函数</strong></li>
</ul>
<pre><code class="language-js">export function Throttle () {
    let start = 0
    // 传入节流时间，整个回调函数，传入回调函数的参数数组，是否自动执行标识
    return function (wait, func, params, trailing) {
        ...
        ...
        return  func(...params)
    }
}
</code></pre>
<ul>
<li><strong>页面调用，传入节流函数的参数</strong></li>
</ul>
<pre><code class="language-js">handleIcon ( index, commentId ) {
    throttle( 3000 , this.handleClick , [ index, commentId ] , 'trailing' )
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[emoji转码]]></title>
        <id>https://luojinan.github.io//post/emoji-zhuan-ma</id>
        <link href="https://luojinan.github.io//post/emoji-zhuan-ma">
        </link>
        <updated>2019-08-11T12:52:06.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>对于移动端，用户有可能输入<code>emoji</code>，并传入数据库，会导致<strong>无法识别而报错</strong></p>
</blockquote>
<blockquote>
<p>这里涉及2个工具方法：
1、<code>utf16的emoji表情字符</code> 转码 成<code>utf8的字符</code>
2、<code>八进制的字符</code> 转码 成<code>十六进制的emoji表情字符</code></p>
</blockquote>
<hr>
<p>[toc]</p>
<hr>
<h3 id="一-emoji转字符">一、emoji转字符</h3>
<pre><code class="language-js">//把utf16的emoji表情字符进行转码成八进制的字符
const utf16toEntities = function(str) {
    // 检测utf16字符正则
    var patt = /[\ud800-\udbff][\udc00-\udfff]/g
    return str.replace(patt, function (char) {
        var H, L, code
        if (char.length === 2) {
            H = char.charCodeAt(0) // 取出高位
            L = char.charCodeAt(1) // 取出低位
            code = (H - 0xD800) * 0x400 + 0x10000 + L - 0xDC00; // 转换算法
            return &quot;&amp;#&quot; + code + &quot;;&quot;
        } else {
            return char
        }
    })
}
</code></pre>
<h3 id="二-字符转emoji">二、字符转emoji</h3>
<pre><code class="language-js">//将编码后的八进制的emoji表情重新解码成十六进制的表情字符
const entitiesToUtf16 = function(str) {
    return str.replace(/&amp;#(\d+);/g, function (match, dec) {
        let H = Math.floor((dec - 0x10000) / 0x400) + 0xD800
        let L = Math.floor(dec - 0x10000) % 0x400 + 0xDC00
        return String.fromCharCode(H, L)
    })
}
</code></pre>
<h3 id="三-转义问题">三、转义问题</h3>
<blockquote>
<p>数据库做了安全处理，返回的字符由<code>&amp;</code>:变成了<code>&amp;amp;</code>，导致<strong>字符转emoji</strong>失败</p>
</blockquote>
<pre><code class="language-js">const changeList = {
    '&amp;': '&amp;amp;',
    '&gt;': '&amp;gt;',
    '&lt;': '&amp;lt;',
    &quot;'&quot;: '&amp;gt;',
    '&quot;': '&amp;quot;',
}
/**
* 由于安全原因, 数据库返回的一些字符是经过转义的, 需要翻译回来
* 返回翻译回来的字符串
*/
function decodeXML (origin) {
    var result = origin
    for (const key in changeList) {
        if (changeList.hasOwnProperty(key)) {
            const item = changeList[key]
            result = result.replace(new RegExp(item, 'gm'), key)
        }
    }
    return result
}
</code></pre>
<ul>
<li><strong>在<code>二、字符转emoji</code>的方法加上，字符转义方法</strong></li>
</ul>
<pre><code class="language-js">//将编码后的八进制的emoji表情重新解码成十六进制的表情字符
const entitiesToUtf16 = function(str) {
     // 数据库返回特殊字符加上了'amp;' 做一遍转义即可
    str = decodeXML(str)
    return str.replace(/&amp;#(\d+);/g, function (match, dec) {
        ...
        ...
    })
}
</code></pre>
<h3 id="四-测试">四、测试</h3>
<pre><code class="language-js">var testStr = &quot;正常的🔥橘🍊💪181848&quot;
var res = utf16toEntities(testStr)
console.log('res', res)
var decode = entitiesToUtf16(res)
console.log('decode', decode)
</code></pre>
<hr>
<p><a href="https://juejin.im/post/5bad9140e51d450e935c6d64">关于转义涉及XSS攻击</a>
如有建议和疑问可联系
QQ：1017386624
邮箱：1017386624@qq.com</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动端grid网格布局]]></title>
        <id>https://luojinan.github.io//post/yi-dong-duan-grid-wang-ge-bu-ju</id>
        <link href="https://luojinan.github.io//post/yi-dong-duan-grid-wang-ge-bu-ju">
        </link>
        <updated>2019-08-11T12:09:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>适用于<strong>移动端块状入口门板</strong>布局，多行</p>
</blockquote>
<blockquote>
<p>应该更适用于<strong>PC端</strong>，自适应浏览器，拉伸缩小，布局改变</p>
</blockquote>
<hr>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%95%88%E6%9E%9C">一、效果</a></li>
<li><a href="#%E4%BA%8C-%E7%A4%BA%E4%BE%8B">二、示例</a>
<ul>
<li><a href="#1-%E7%A4%BA%E4%BE%8B1">1、示例1</a></li>
<li><a href="#2-%E7%A4%BA%E4%BE%8B2">2、示例2</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-pc%E7%AB%AF%E7%A4%BA%E4%BE%8B">三、PC端示例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<hr>
<h3 id="一-效果">一、效果</h3>
<p><img src="https://luojinan.github.io//post-images/1565525457735.png" alt=""></p>
<h3 id="二-示例">二、示例</h3>
<h4 id="1-示例1">1、示例1</h4>
<blockquote>
<p>第一种示例只需要在<strong>父级</strong>写<code>grid</code>布局即可
<code>列2端对齐、中间列居中</code>
<code>中间行边距设值</code></p>
</blockquote>
<ul>
<li><strong>html</strong>
<img src="https://luojinan.github.io//post-images/1565525471452.png" alt=""></li>
<li><strong>外层css</strong>
<img src="https://luojinan.github.io//post-images/1565525484221.png" alt=""></li>
</ul>
<pre><code class="language-css">.parent{
    display: grid;
    grid-template: auto auto auto / auto auto auto;
    grid-row-gap: 36rpx;
    
    justify-content: space-between;
    justify-items: center;
    
    align-items: center;
}
</code></pre>
<ul>
<li><strong>内层css</strong>
<img src="https://luojinan.github.io//post-images/1565525493678.png" alt=""></li>
</ul>
<hr>
<h4 id="2-示例2">2、示例2</h4>
<p><img src="https://luojinan.github.io//post-images/1565525498059.png" alt=""></p>
<blockquote>
<p>第二种示例<strong>父级、子级</strong>都要写<code>grid</code>布局
<code>列间距设值</code>
<code>行间距设值</code>
<code>第一个子项占2列</code></p>
</blockquote>
<ul>
<li><strong>外层css</strong>
<img src="https://luojinan.github.io//post-images/1565525503568.png" alt=""></li>
</ul>
<pre><code class="language-css">parent{
    display: grid;
    grid-template: auto auto auto / auto auto auto;
    grid-row-gap: 20rpx;
    grid-column-gap: 20rpx;
}
</code></pre>
<ul>
<li><strong>内层css</strong>
<img src="https://luojinan.github.io//post-images/1565525513532.png" alt=""></li>
</ul>
<pre><code class="language-scss">child-item {
    ...
    &amp;:first-child {
        grid-column-start: 1;
        grid-column-end: 3;
    }
}
</code></pre>
<hr>
<h3 id="三-pc端示例">三、PC端示例</h3>
<blockquote>
<p>不止布局在自适应，单个<code>item</code>也在<strong>自适应</strong>(<code>flex</code>等自适应方案难做到)</p>
</blockquote>
<p><img src="https://luojinan.github.io//post-images/1565525521555.gif" alt="">
<a href="https://juejin.im/post/5d46c169e51d4562132030a0#heading-15">PC端掘金博客</a>
<a href="https://www.w3cplus.com/css3/how-the-minmax-function-works.html">minmax属性</a></p>
<hr>
<p>另外单位：<code>1fr</code>
等同于<code>flex布局</code>的<code>flex: 1;</code></p>
<hr>
<p>如有建议和疑问可联系
QQ：1017386624
邮箱：1017386624@qq.com</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一行代码去重数组]]></title>
        <id>https://luojinan.github.io//post/yi-xing-dai-ma-qu-chong-shu-zu</id>
        <link href="https://luojinan.github.io//post/yi-xing-dai-ma-qu-chong-shu-zu">
        </link>
        <updated>2019-08-10T01:54:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一行代码去重数组">一行代码去重数组</h3>
<p><img src="https://luojinan.github.io//post-images/1565402943271.png" alt=""></p>
<blockquote>
<p>注意<code>new Set()</code>返回的是一个set对象，而不是直接返回去重后的数组
因此，把该对象展开并放入空数组中，才能形成一个数组</p>
</blockquote>
<pre><code class="language-js">const list = [1, 1, 2, 3, 6, 45, 8, 5, 4, 6, 5]
const uniqueList = [...new Set(list)] // [1, 2, 3, 6, 45, 8, 5, 4]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试文章]]></title>
        <id>https://luojinan.github.io//post/测试文章</id>
        <link href="https://luojinan.github.io//post/测试文章">
        </link>
        <updated>2019-07-10T16:20:30.000Z</updated>
        <summary type="html"><![CDATA[<p>？？？</p>
]]></summary>
        <content type="html"><![CDATA[<p>？？？</p>
<!-- more -->
<p>现在写博客的地方有：CSDN、印象笔记、Gridea。</p>
<p>1、CSDN和印象笔记的图片不互通
2、印象笔记无法自定义封面和摘要</p>
<hr>
<p>Gridea：	
1、图片上传到github有时候加载不出来...本地预览可以，线上版本不行
2、测试图片有没有可能会挂掉，永久有效就用来做印象笔记和CSDN的图床
3、除了文章的代码块，Gridea能不能上传代码文件，还是要同样要链接到github代码库
4、以后的写笔记顺序： 印象笔记--&gt;Gridea--&gt;修改--&gt;Gridea发布--&gt;CSDN发布</p>
<p><img src="https://luojinan.github.io//post-images/1562895205737.jpg" alt="测试图片"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://luojinan.github.io//post/hello-gridea</id>
        <link href="https://luojinan.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>